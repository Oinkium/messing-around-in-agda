module categories where

open import Level public
  renaming (_âŠ”_ to _âŠ_ ; zero to â„“â‚€ ; suc to â„“suc)

data _â‰¡_ {â„“ : Level} {A : Set â„“} : A â†’ A â†’ Set where
  refl : (x : A) â†’ x â‰¡ x

symm : {â„“ : Level} {A : Set â„“} {x : A} {y : A} â†’ (x â‰¡ y) â†’ (y â‰¡ x)
symm (refl x) = refl x

trans : {â„“ : Level} {A : Set â„“} {x : A} {y : A} {z : A} â†’ (x â‰¡ y) â†’ (y â‰¡ z) â†’ (x â‰¡ z)
trans {â„“} {A} {.x} {.x} {.x} (refl .x) (refl x) = refl x

app : {â„“ : Level} {A : Set â„“} {B : Set â„“} {x : A} {y : A} (f : A â†’ B) â†’ (x â‰¡ y) â†’ ((f x) â‰¡ (f y))
app f (refl z) = refl (f z)

-- Dependent pair type

record Î£ (A : Set) (B : A â†’ Set) : Set where
  constructor _,_
  field
    projl : A
    projr : B projl

-- Categories and functors

record Category {â„“ : Level} : Set (â„“suc â„“) where
  field
    objects : Set â„“
    morphisms : objects â†’ objects â†’ Set
    _âˆ˜_ : {A : objects} â†’ {B : objects} â†’ {C : objects} â†’ morphisms B C â†’ morphisms A B â†’ morphisms A C
    id : {A : objects} â†’ morphisms A A
    assoc : {A : objects} â†’ {B : objects} â†’ {C : objects} â†’ {D : objects} â†’ (f : morphisms A B) â†’ (g : morphisms B C) â†’ (h : morphisms C D) â†’ ((h âˆ˜ g) âˆ˜ f) â‰¡ (h âˆ˜ (g âˆ˜ f))
    leftId : {A : objects} â†’ {B : objects} â†’ (f : morphisms A B) â†’ (id âˆ˜ f) â‰¡ f
    rightId : {A : objects} â†’ {B : objects} â†’ (f : morphisms A B) â†’ (f âˆ˜ id) â‰¡ f

Ob : Category â†’ Set
Ob ğ’ = Category.objects ğ’

Mor : {ğ’ : Category} â†’ Ob ğ’ â†’ Ob ğ’ â†’ Set
Mor {ğ’} A B = Category.morphisms ğ’ A B

id : {ğ’ : Category} â†’ (A : Ob ğ’) â†’ Mor {ğ’} A A
id {ğ’} A = Category.id ğ’ {A}

_âˆ˜_ : {ğ’ : Category} {A : Ob ğ’} {B : Ob ğ’} {C : Ob ğ’} â†’ Mor {ğ’} B C â†’ Mor {ğ’} A B â†’ Mor {ğ’} A C
_âˆ˜_ {ğ’} g f = Category._âˆ˜_ ğ’ g f

record Functor (ğ’ ğ’Ÿ : Category) : Set where
  field
    onObjects : Category.objects ğ’ â†’ Category.objects ğ’Ÿ
    onMorphisms : {A : Category.objects ğ’} â†’ {B : Category.objects ğ’} â†’ (Category.morphisms ğ’ A B) â†’ (Category.morphisms ğ’Ÿ (onObjects A) (onObjects B))
    respectsComposition : {A : Category.objects ğ’} â†’ {B : Category.objects ğ’} â†’ {C : Category.objects ğ’} â†’ (f : Category.morphisms ğ’ A B) â†’ (g : Category.morphisms ğ’ B C) â†’ (onMorphisms (Category._âˆ˜_ ğ’ g f)) â‰¡ (Category._âˆ˜_ ğ’Ÿ (onMorphisms g) (onMorphisms f))
    respectsIdentity : {A : Category.objects ğ’} â†’ (onMorphisms (Category.id ğ’ {A})) â‰¡ (Category.id ğ’Ÿ {onObjects A}) 

_â—_ : {ğ’ : Category} â†’ {ğ’Ÿ : Category} â†’ {ğ’¦ : Category} â†’ Functor ğ’Ÿ ğ’¦ â†’ Functor ğ’ ğ’Ÿ â†’ Functor ğ’ ğ’¦
ğ’¯ â— ğ’® = record { onObjects = Î» A â†’ (Functor.onObjects ğ’¯) (Functor.onObjects ğ’® A) ; onMorphisms = Î» f â†’ (Functor.onMorphisms ğ’¯) (Functor.onMorphisms ğ’® f) ; respectsComposition = Î» f â†’ Î» g â†’ trans (app (Functor.onMorphisms ğ’¯) (Functor.respectsComposition ğ’® f g)) (Functor.respectsComposition ğ’¯ (Functor.onMorphisms ğ’® f) (Functor.onMorphisms ğ’® g)) ; respectsIdentity = trans (app (Functor.onMorphisms ğ’¯) (Functor.respectsIdentity ğ’®)) (Functor.respectsIdentity ğ’¯) }

-- Arrow categories

record Arrow (ğ’ : Category) : Set where
  field
    left : Ob ğ’
    right : Ob ğ’
    arrow : Mor {ğ’} left right

left : {ğ’ : Category} â†’ (â†— : Arrow ğ’) â†’ Ob ğ’
left â†— = Arrow.left â†—

right : {ğ’ : Category} â†’ (â†— : Arrow ğ’) â†’ Ob ğ’
right â†— = Arrow.right â†—

arrow : {ğ’ : Category} â†’ (â†— : Arrow ğ’) â†’ Mor {ğ’} (left â†—) (right â†—)
arrow â†— = Arrow.arrow â†—

record CommutativeSquare (ğ’ : Category) : Set where
  field
    NW : Ob ğ’
    NE : Ob ğ’
    SW : Ob ğ’
    SE : Ob ğ’
    north : Mor {ğ’} NW NE
    west : Mor {ğ’} NW SW
    east : Mor {ğ’} NE SE
    south : Mor {ğ’} SW SE
    comm : _âˆ˜_ {ğ’} east north â‰¡ _âˆ˜_ {ğ’} south west

NW : {ğ’ : Category} â†’ (â–¡ : CommutativeSquare ğ’) -> Ob ğ’
NW â–¡ = CommutativeSquare.NW â–¡

NE : {ğ’ : Category} â†’ (â–¡  : CommutativeSquare ğ’) -> Ob ğ’
NE â–¡ = CommutativeSquare.NE â–¡

SW : {ğ’ : Category} â†’ (â–¡  : CommutativeSquare ğ’) -> Ob ğ’
SW â–¡ = CommutativeSquare.SW â–¡

SE : {ğ’ : Category} â†’ (â–¡  : CommutativeSquare ğ’) -> Ob ğ’
SE â–¡ = CommutativeSquare.SE â–¡

north : {ğ’ : Category} â†’ (â–¡ : CommutativeSquare ğ’) -> Mor {ğ’} (NW â–¡) (NE â–¡)
north â–¡ = CommutativeSquare.north â–¡

west : {ğ’ : Category} â†’ (â–¡ : CommutativeSquare ğ’) -> Mor {ğ’} (NW â–¡) (SW â–¡)
west â–¡ = CommutativeSquare.west â–¡

east : {ğ’ : Category} â†’ (â–¡ : CommutativeSquare ğ’) -> Mor {ğ’} (NE â–¡) (SE â–¡)
east â–¡ = CommutativeSquare.east â–¡

south : {ğ’ : Category} â†’ (â–¡ : CommutativeSquare ğ’) -> Mor {ğ’} (SW â–¡) (SE â–¡)
south â–¡ = CommutativeSquare.south â–¡

topArrow : {ğ’ : Category} â†’ CommutativeSquare ğ’ â†’ Arrow ğ’
topArrow â–¡ = record { left = NW â–¡ ; right = NE â–¡ ; arrow = north â–¡ }

bottomArrow : {ğ’ : Category} â†’ CommutativeSquare ğ’ â†’ Arrow ğ’
bottomArrow â–¡ = record { left = SW â–¡ ; right = SE â–¡ ; arrow = south â–¡ }

_âˆ·_ : {ğ’ : Category} â†’ (â–¡ : CommutativeSquare ğ’) â†’ (â–  : CommutativeSquare ğ’) -> (south â–¡) â‰¡ (north â– ) -> CommutativeSquare ğ’
_âˆ·_ {ğ’} â–¡ â–  P = record{ NW = NW â–¡ ; NE = NE â–¡ ; SW = SW â–  ; SE = SE â–  ; north = north â–¡ ; west = _âˆ˜_ {ğ’} (west â– ) (west â–¡) ; east = _âˆ˜_ {ğ’} (east â– ) (east â–¡) ; south = south â–  ; comm = trans (trans (trans (trans (trans (Category.assoc ğ’ (north â–¡) (east â–¡) (east â– )) (app (Î» f â†’ _âˆ˜_ {ğ’} (east â– ) f) (CommutativeSquare.comm â–¡))) (Category.assoc ğ’ (west â–¡) (south â–¡) (east â– ))) (app (Î» f â†’ _âˆ˜_ {ğ’} (_âˆ˜_ {ğ’} (east â– ) f) (west â–¡)) P)) (app (Î» f â†’ (_âˆ˜_ {ğ’} f (west â–¡))) (CommutativeSquare.comm â– ))) (Category.assoc ğ’ (west â–¡) (west â– ) (south â– )) }

-- The category of sets

CategoryOfSets : Category {â„“suc â„“â‚€}
CategoryOfSets = record {objects = Set ; morphisms = Î» A â†’ Î» B â†’ (A â†’ B) ; _âˆ˜_ = Î» g â†’ Î» f â†’ Î» x â†’ g (f x) ; id = Î» x â†’ x ; assoc = Î» f â†’ Î» g â†’ Î» h â†’ refl (Î» x â†’ h (g (f x))) ; leftId = Î» f â†’ refl f ; rightId = Î» f â†’ refl f }
  
-- An example poset category

data â„• : Set where
  zero : â„•
  succ : â„• â†’ â„•

_+_ : â„• â†’ â„• â†’ â„•
zero + n = n
(succ M) + n = succ(M + n)

â„•asc : (l : â„•) â†’ (m : â„•) â†’ (n : â„•) â†’ ((l + m) + n) â‰¡ (l + (m + n))
â„•asc zero m n = refl (m + n)
â„•asc (succ L) m n = app succ (â„•asc L m n)

â„•unitL : (n : â„•) â†’ (zero + n) â‰¡ n
â„•unitL n = refl n

â„•unitR : (n : â„•) â†’ (n + zero) â‰¡ n
â„•unitR zero = refl zero
â„•unitR (succ N) = app succ (â„•unitR N)

data _â‰¤_ : â„• â†’ â„• â†’ Set where
  zer : {n : â„•} â†’ zero â‰¤ n
  inc : {m : â„•} â†’ {n : â„•} â†’ (m â‰¤ n) â†’ (succ m â‰¤ succ n)

ref : {n : â„•} â†’ n â‰¤ n
ref {zero} = zer
ref {succ n} = inc (ref {n})

tra : {l : â„•} â†’ {m : â„•} â†’ {n : â„•} â†’ l â‰¤ m â†’ m â‰¤ n â†’ l â‰¤ n
tra zer Q = zer
tra (inc P) (inc Q) = inc (tra P Q)

unq : {m : â„•} â†’ {n : â„•} â†’ (P : m â‰¤ n) â†’ (Q : m â‰¤ n) â†’ (P â‰¡ Q)
unq zer zer = refl zer
unq (inc P) (inc Q) = app inc (unq P Q)

Categoryâ„• : Category {â„“â‚€}
Categoryâ„• = record { objects = â„• ; morphisms = Î» m â†’ Î» n â†’ (m â‰¤ n) ; _âˆ˜_ = Î» Q â†’ Î» P â†’ tra P Q ; id = ref ; assoc = Î» P â†’ Î» Q â†’ Î» R â†’ unq (tra P (tra Q R)) (tra (tra P Q) R) ; leftId = Î» P â†’ unq (tra P ref) P ; rightId = Î» P â†’ unq (tra ref P) P }

-- A monoid as a category

record Monoid : Setâ‚ where
  field
    carrier : Set
    _âœ¶_ : carrier â†’ carrier â†’ carrier
    e : carrier
    assoc : (x : carrier) â†’ (y : carrier) â†’ (z : carrier) â†’ ((x âœ¶ y) âœ¶ z) â‰¡ (x âœ¶ (y âœ¶ z))
    idL : (x : carrier) â†’ (e âœ¶ x) â‰¡ x
    idR : (y : carrier) â†’ (y âœ¶ e) â‰¡ y

data Point : Set where
  â‹† : Point

MonoidAsCategory : Monoid â†’ Category {â„“â‚€}
MonoidAsCategory M = record { objects = Point ; morphisms = Î» â‹† â†’ Î» â‹† â†’ Monoid.carrier M ; _âˆ˜_ = Î» x â†’ Î» y â†’ (Monoid._âœ¶_ M) x  y ; id = Monoid.e M ; assoc = Î» x â†’ Î» y â†’ Î» z â†’ Monoid.assoc M z y x ; leftId = Monoid.idL M ; rightId = Monoid.idR M }

-- And a silly example

â„•AsMonoid : Monoid
â„•AsMonoid = record { carrier = â„• ; _âœ¶_ = Î» m â†’ Î» n â†’ m + n ; e = zero ; assoc = â„•asc ; idL = â„•unitL ; idR = â„•unitR }

â„•AsMonoidAsCategory : Category {â„“â‚€}
â„•AsMonoidAsCategory = MonoidAsCategory â„•AsMonoid
